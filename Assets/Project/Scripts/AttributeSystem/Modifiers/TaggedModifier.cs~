using System;
using System.Collections.Generic;
using Project.Scripts.AttributeSystem.AttributeTypes;
using Project.Scripts.Util.Builder;
using Project.Scripts.Util.Visitor;
using UnityEngine;

namespace Project.Scripts.AttributeSystem.Modifiers;

/// <summary>
/// Base class for a modifier.
/// </summary>
/// <typeparam name="K">The enum type representing the attribute modifiable by the modifier.</typeparam>
[Serializable]
public abstract class Modifier<K> : IVisitor<ModifierManager> where K : Enum {
    [field: SerializeField, Header("Modifier Type")] 
    public K Target { get; protected set; }
    
    [field: SerializeField] 
    public ModifierType ValueType { get; protected set; }
    
    [field: SerializeField] 
    public ModifierOperation OperationType { get; protected set; }
    
    protected Modifier(K target, ModifierType valueType, ModifierOperation operation) {
        this.Target = target;
        this.ValueType = valueType;
        this.OperationType = operation;
    }

    protected virtual Modifier<K> BasedOn(AttributeSet? self, AttributeSet target) {
        return this;
    }
    
    protected virtual Modifier<K> With(IReadOnlyDictionary<string, int> magnitudes) {
        return this;
    }

    protected virtual Modifier<K> With(string label, int magnitude) {
        return this;
    }

    protected abstract float Evaluate();

    public void Visit(ModifierManager manager) {
        manager.AddModifier(this);
    }
    
    public static Vector4 operator +(Vector4 vec, Modifier<K> mod) {
        switch (mod.ValueType) {
            case ModifierType.Base:
                switch (mod.OperationType) {
                    case ModifierOperation.Offset:
                        return new Vector4(vec.x + mod.Evaluate(), vec.y, vec.z, vec.w);
                    case ModifierOperation.Multiplier:
                        return new Vector4(vec.x, vec.y + mod.Evaluate(), vec.z, vec.w);
                }
                break;
            case ModifierType.Current:
                switch (mod.OperationType) {
                    case ModifierOperation.Offset:
                        return new Vector4(vec.x, vec.y, vec.z + mod.Evaluate(), vec.w);
                    case ModifierOperation.Multiplier:
                        return new Vector4(vec.x, vec.y, vec.z, vec.w + mod.Evaluate());
                }
                break;
        }

        return vec;
    }
    
    public static Vector4 operator -(Vector4 vec, Modifier<K> mod) {
        switch (mod.ValueType) {
            case ModifierType.Base:
                switch (mod.OperationType) {
                    case ModifierOperation.Offset:
                        return new Vector4(vec.x - mod.Evaluate(), vec.y, vec.z, vec.w);
                    case ModifierOperation.Multiplier:
                        return new Vector4(vec.x, vec.y - mod.Evaluate(), vec.z, vec.w);
                }
                break;
            case ModifierType.Current:
                switch (mod.OperationType) {
                    case ModifierOperation.Offset:
                        return new Vector4(vec.x, vec.y, vec.z - mod.Evaluate(), vec.w);
                    case ModifierOperation.Multiplier:
                        return new Vector4(vec.x, vec.y, vec.z, vec.w - mod.Evaluate());
                }
                break;
        }

        return vec;
    }

    public sealed class Configurator : FluentBuilder<Modifier<K>> {
        private Configurator(Modifier<K> template) : base(template) { }
        
        public static Configurator Of(Modifier<K> template) => new Configurator(template);

        public Configurator BasedOn(AttributeSet? self, AttributeSet target) {
            this.Template = this.Template.BasedOn(self, target);
            return this;
        }
        
        public Configurator With(string label, int magnitude) {
            this.Template = this.Template.With(label, magnitude);
            return this;
        }

        public Configurator AccordingTo(IReadOnlyDictionary<string, int> magnitudes) {
            this.Template = this.Template.With(magnitudes);
            return this;
        }
    }
}