using System;
using UnityEngine;

namespace Project.Scripts.AttributeSystem.Modifiers;

[Serializable]
public sealed class AttributeBasedModifier : Modifier {
    public enum Combiner {
        Additive,
        Multiplicative,
        Max,
        Min,
        Average,
        Difference,
        SelfToTargetRatio,
        TargetToSelfRatio,
        SelfMinusTarget,
        TargetMinusSelf
    }

    public AttributeBasedModifier(
        AttributeType target, Type valueType, Operation operation, Combiner combinerType = Combiner.Additive,
        float coefficient = 1, BackingAttribute? selfBackingAttribute = null,
        BackingAttribute? targetBackingAttribute = null
    ) : base(target, valueType, operation) {
        this.SelfBackingAttribute = selfBackingAttribute;
        this.TargetBackingAttribute = targetBackingAttribute;
        this.CombinerType = combinerType;
        this.Coefficient = coefficient;
    }

    [field: SerializeField, Header("Magnitude")] 
    private BackingAttribute? SelfBackingAttribute { get; set; }
    
    [field: SerializeField] 
    private BackingAttribute? TargetBackingAttribute { get; set; }

    [field: SerializeField]
    private Combiner CombinerType { get; set; }
    
    [field: SerializeField] 
    private float Coefficient { get; set; }
    
    private AttributeSet? SelfAttributes { get; set; }
    private AttributeSet? TargetAttributes { get; set; }

    private float Identity => this.CombinerType switch {
        Combiner.Multiplicative => 1,
        Combiner.Max => float.MinValue,
        Combiner.Min => float.MaxValue,
        var _ => 0
    };
    
    private float Calculate(float selfValue, float targetValue) {
        return this.CombinerType switch {
            Combiner.Additive => selfValue + targetValue,
            Combiner.Multiplicative => selfValue * targetValue,
            Combiner.Max => Mathf.Max(selfValue, targetValue),
            Combiner.Min => Mathf.Min(selfValue, targetValue),
            Combiner.Average => (selfValue + targetValue) / 2,
            Combiner.Difference => Mathf.Abs(selfValue - targetValue),
            Combiner.SelfToTargetRatio => targetValue == 0 ? float.MaxValue : selfValue / targetValue,
            Combiner.TargetToSelfRatio => selfValue == 0 ? float.MaxValue : targetValue / selfValue,
            Combiner.SelfMinusTarget => selfValue - targetValue,
            Combiner.TargetMinusSelf => targetValue - selfValue,
            var _ => 0
        };
    }

    protected override float Evaluate() {
        if (this.SelfBackingAttribute == null && this.TargetBackingAttribute == null) {
            return 0;
        }

        float selfValue = this.Identity;
        float targetValue = this.Identity;
        if (this.SelfBackingAttribute != null && this.SelfAttributes != null) {
            selfValue = this.SelfBackingAttribute.EvaluateUsing(this.SelfAttributes);
        }
        
        if (this.TargetBackingAttribute != null && this.TargetAttributes != null) {
            targetValue = this.TargetBackingAttribute.EvaluateUsing(this.TargetAttributes);
        }
        
        return this.Coefficient * this.Calculate(selfValue, targetValue);
    }

    protected override Modifier BasedOn(AttributeSet? self, AttributeSet target) {
        return new AttributeBasedModifier(this.Target, this.ValueType, this.OperationType, this.CombinerType,
            this.Coefficient, this.SelfBackingAttribute, this.TargetBackingAttribute) {
            SelfAttributes = self,
            TargetAttributes = target
        };
    }
}